package hibe

import (
	"bytes"
	"crypto/sha256"
	"encoding/json"
	"fmt"

	"github.com/Nik-U/pbc"
)

var pairing *pbc.Pairing

// gentry designates a protocol instance holding the public parameters or the root entity.
type gentry struct {
	P0, Q0 *pbc.Element // P0 and Q0 are the generator elements of a protocol instance.
}

// gentryEntity designates a participant in the protocol. It can be both the root PKG,
// intermediate PKG or a simple user.
type gentryEntity struct {
	ID [][]byte // ID is the public key of the entity.

	St *pbc.Element // St is the constant secret scalar created when the entity comes to life.
	S  *pbc.Element // S is the ephemeral secret received upon secret key extraction.

	Q []*pbc.Element // Q is a list of generator values from ancestor identities.
}

// gentryCiphertext splits and bundles a cipher text tuple.
type gentryCiphertext struct {
	U []*pbc.Element // U is the first element of the tuple.
	V []byte         // V is the second element of the tuple.
}

// NewGentry creates a fresh protocol instance over symmetric pairing of groupe size r bits
// and an underlying finite field of size q bits.
func NewGentry(r, q uint32) *gentry {
	pairing = pbc.GenerateA(r, q).NewPairing()
	return &gentry{}
}

// Setup establishes the public parameters and generates a root entity PKG.
func (g *gentry) Setup() ([]byte, error) {
	g.P0 = pairing.NewG1().Rand()

	s0 := pairing.NewZr().Rand()
	g.Q0 = pairing.NewG1().MulZn(g.P0, s0)

	// Set ephemeral secret to the identity element.
	root := &gentryEntity{
		ID: [][]byte{},
		St: s0, S: pairing.NewG1().Set1(),
		Q: []*pbc.Element{},
	}
	return root.MarshalJSON()
}

// Extract generates a fresh child entity specified by id from a ancestor entity.
func (g gentry) Extract(ancestor []byte, id [][]byte) ([]byte, error) {
	var e gentryEntity
	if err := e.UnmarshalJSON(ancestor); err != nil {
		return nil, err
	}

	if len(e.ID)+1 != len(id) {
		return nil, fmt.Errorf("invalid id heights ancestor=%d child=%d", len(e.ID), len(id))
	}
	for i, b := range e.ID {
		if !bytes.Equal(b, id[i]) {
			return nil, fmt.Errorf("ancestor id=%v is not prefix of child id=%v", e.ID, id)
		}
	}

	P := pairing.NewG1().SetFromStringHash(string(bytes.Join(id, nil)), sha256.New())
	S := pairing.NewG1().Add(e.S, pairing.NewG1().MulZn(P, e.St))

	// FIXME: Constant secret should not be generated by the ancestor during key extraction
	// but at the beginning during the protocol setup.
	St := pairing.NewZr().Rand()
	Q := append(e.Q, pairing.NewG1().MulZn(g.P0, e.St))

	child := &gentryEntity{
		ID: id,
		St: St, S: S,
		Q: Q,
	}
	return child.MarshalJSON()
}

// Encrypt encrypts a message for a given id.
func (g gentry) Encrypt(message []byte, id [][]byte) ([]byte, error) {
	P := make([]*pbc.Element, len(id))
	for i := 0; i < len(id); i++ {
		P[i] = pairing.NewG1().SetFromStringHash(string(bytes.Join(id[:i+1], nil)), sha256.New())
	}

	r := pairing.NewZr().Rand()

	paired := pairing.NewGT().Pair(g.Q0, P[0])
	h := pairing.NewGT().MulZn(paired, r).Bytes()
	V := xor(message, h)

	ct := gentryCiphertext{V: V}

	ct.U = make([]*pbc.Element, len(id)+1)
	ct.U[0] = pairing.NewG1().MulZn(g.P0, r)
	ct.U[1] = nil
	for i := 2; i <= len(id); i++ {
		ct.U[i] = pairing.NewG1().MulZn(P[i-1], r)
	}

	return ct.MarshalJSON()
}

// Decrypt decrypts a given ciphertext using the secret key material of an entity.
func (g gentry) Decrypt(entity, ct []byte) ([]byte, error) {
	var e gentryEntity
	if err := e.UnmarshalJSON(entity); err != nil {
		return nil, err
	}

	var c gentryCiphertext
	if err := c.UnmarshalJSON(ct); err != nil {
		return nil, err
	}

	k := pairing.NewGT().Pair(c.U[0], e.S)
	for i := 2; i < len(c.U); i++ {
		k = pairing.NewGT().Sub(k, pairing.NewGT().Pair(e.Q[i-1], c.U[i]))
	}

	return xor(c.V, k.Bytes()), nil
}

// xor computes the exclusive-or of two byte arrays.
func xor(a, b []byte) []byte {
	c := make([]byte, len(a))
	for i := range a {
		c[i] = a[i] ^ b[i]
	}
	return c
}

// gentryEntityPacket is a helper structure that enables marshalling and unmarshalling.
type gentryEntityPacket struct {
	ID    [][]byte
	St, S []byte
	Q     [][]byte
}

func (e gentryEntity) MarshalJSON() ([]byte, error) {
	packet := gentryEntityPacket{ID: e.ID, St: e.St.Bytes(), S: e.S.Bytes()}
	for _, q := range e.Q {
		packet.Q = append(packet.Q, q.Bytes())
	}
	return json.Marshal(&packet)
}

func (e *gentryEntity) UnmarshalJSON(data []byte) error {
	var packet gentryEntityPacket
	if err := json.Unmarshal(data, &packet); err != nil {
		return err
	}

	e.ID = packet.ID
	e.St = pairing.NewZr().SetBytes(packet.St)
	e.S = pairing.NewG1().SetBytes(packet.S)
	for _, q := range packet.Q {
		e.Q = append(e.Q, pairing.NewG1().SetBytes(q))
	}
	return nil
}

// gentryCiphertextPacket is a helper structure that enables marshalling and unmarshalling.
type gentryCiphertextPacket struct {
	U [][]byte
	V []byte
}

func (c gentryCiphertext) MarshalJSON() ([]byte, error) {
	packet := &gentryCiphertextPacket{V: c.V}
	for _, u := range c.U {
		if u != nil {
			packet.U = append(packet.U, u.Bytes())
		} else {
			packet.U = append(packet.U, nil)
		}
	}
	return json.Marshal(&packet)
}

func (c *gentryCiphertext) UnmarshalJSON(data []byte) error {
	var packet gentryCiphertextPacket
	if err := json.Unmarshal(data, &packet); err != nil {
		return err
	}

	c.V = packet.V
	for _, u := range packet.U {
		if u != nil {
			c.U = append(c.U, pairing.NewG1().SetBytes(u))
		} else {
			c.U = append(c.U, nil)
		}
	}
	return nil
}
