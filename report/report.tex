\documentclass[11pt,a4paper,twoside,openright,bibliography=totoc]{scrbook}

\usepackage{scrhack}
\usepackage{graphicx,xcolor,float}
\usepackage{amssymb,amsmath,array}
\usepackage{varwidth,algpseudocode}

\usepackage{tikz}
\usetikzlibrary{positioning,arrows,calc,intersections}

% Color citation, references and links.
\usepackage{url,hyperref}
\hypersetup{
  colorlinks,
  linkcolor={black},
  citecolor={red!70!black},
  urlcolor={blue!70!black}
}
\usepackage[labelfont=bf]{caption} % Bold figure titles.

\renewcommand{\t}{\text} % Shorten \text command.

\begin{document}
\input{cover/cover}
\tableofcontents

\chapter{Introduction}
\label{chap:introduction}

Messaging has become an ubiquitous resource in the daily lives of
millions of people around the globe through the widespread adoption of
instant messaging applications. The design of protocols which
facilitate securing messaging or key-agreement is faced with a unique
set of challenges, this is due to the longevity of sessions between
communicating parties and the inherently asynchronous notion of
messaging where a participant is both the sender and recipient of
messages and the time a message is sent or received is undefined. In
such a setting the leakage of a state to the adversary is especially
devastating since in a naive protocol it would not only enable him to
recover past messages but also allow future impersonations of the
victim.
Ratcheting has established itself as the go-to technique in
order to mitigate these risks. Akin to its mechanical equivalent the
states are continuously moved forward (updated) without the
possibility of going backwards, i.e.~it should be impossible to
recover past states from the current one.
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.1]{figures/ratchet-icon.eps}
  \caption{Symbolic Ratchet Wheel}
  \label{fig:ratchet-wheel}
\end{figure}
This further implies that
past message remain secure even in the presence of and adversary who
can expose the state of a participant. The literature labels protocols
that deploy ratchets as \textit{forward-secure}. This technique saw
its inception in 2004 as part of the Off-the-Record messaging
protocol~\cite{borisov2004off}. It only recently gained traction
through the massively popular Signal protocol~\cite{perrin2016double}.
The release of this protocol however predates its first formal
security analysis in 2017~\cite{cohn2017formal}
and since then several novel protocols with various degrees of
security levels have been proposed. Among others
these protocols also attempt the satisfy the notion of \textit{future
secrecy} in which future states and messages remain secure even if the
current state has been leaked. Furthermore, a secure messaging
protocol should be efficient enough to run smoothly even on
computationally inferior devices thus the choice of fast primitives
that do not compromise the promised security levels play a crucial
part in the construction of messaging protocols. Even though on paper
the attained levels of security in these new protocol often only
differ marginally the effects on performance metrics are of a
different kind with sometimes huge differences between the protocols.

% Add some more text here.

\section{Contributions}
\label{sec:contributions}

This project is concerned with surveying and solidifying the
performance differences of six new secure messaging or key-update
protocols that have been proposed during the past two years. In
chapter~\ref{chap:protocols} the notion of secure messaging and
especially ratcheting is formally reviewed before each protocol is
summarized in terms of composition and security levels, then in
chapter~\ref{chap:benchmarks} the protocols are measured and compared
on the basis of several benchmarks. In chapter~\ref{chap:bark} we
extend and modify the in-house Bidirectional Asynchronous Ratcheted
Key Agreement protocol (BARK) proposed by the LASEC laboratory into a
faster version with only minor concessions in terms of security before
concluding this report in the last chapter.

\section{Circumstances}
\label{sec:circumstances}

This project has been conducted as part of the third master semester optional
semester project in computer science course (CS-596) offered by the
School of Computer and Communications Sciences at EPFL and is credited
with eight points. It was supervised by Doctor Bet√ºl Durak of
the LASEC laboratory.

\chapter{Protocols}
\label{chap:protocols}

As laid out in the introduction the Signal~\cite{perrin2016double}
protocol created and deployed well before the establishment of a
serious secure messaging definition thus it is lacking any form of
security proof. The subsequent analysis in 2007~\cite{cohn2017formal}
was then more concerned with proving the security of specific Signal
instances than treating the general case of securing
messaging. Formally, ratcheted messaging attempts to satisfy some
correctness and security notions.


\section{Ratcheted Messaging}
\label{sec:ratcheted-messaging}

For the remainder of this text let Alice and Bob be the communicating
parties through an insecure channel. Alice and Bob take on random
roles throughout their communication and are not necessarily
synchronized meaning that the reception of sent messages may be
delayed to a point where there are already new messages in the channel
travelling in the opposite direction. Note that this does not imply
that messages may be dropped or received in a different order than
they were initially sent in, this will be important later on when
the actual protocols are described.
\begin{figure}[ht]
  \centering
  \input{figures/traffic.tikz} 
  \caption{Example of Ratcheted Traffic}
  \label{fig:traffic}
\end{figure}
Figure~\ref{fig:traffic}
shows an example asynchronous traffic transcript. The initial states
of Alice and Bob are created and distributed by a trusted party, these
states are updated with each send or receive operation. In the case
of a key-agreement protocol the update information corresponding to
the created key of the sender should generate the same key at
the receiver when the update message is received. Analogous,
for a messaging protocol where a encrypted message should be
correctly deciphered by the receiver upon arrival. In figure
% TODO: insert figure here
for example the message sent by Alice at time $t_0$ is only
received by Bob at time $t_8$ but should nonetheless produce
a correct key or plaintext regardless of the messages sent
by Bob in the meantime that updated Bob's state.

\section{Ratchet Security}
\label{sec:ratchet-security}

These continuous updates of the states are supposed to be irreversible
such that past states may not be derived from any future state thus
yielding forward security protecting past messages from being
compromised. This was the original goal that ratcheting tried to
achieve. Naively, a ratchet can be constructed through the usage of a
one-way function the simply updates the states of the communicating
parties. In practice, a hash-function would be deployed as a
reasonable alternative with the downside of losing the asynchronous
communication property~\cite{bellare2003forward}. On the other hand if
some randomness is included in the creation of an updated state we can
protect future states from being recreated by an adversary after an
exposure yielding future secrecy or post-compromise security. Another
way is the usage of some key-agreement protocol to schedule the
creation of new states between the parties~\cite{cohn2016post}.  Again
both constructions come at the cost of losing asynchronous
communications. Asynchronous communications is thus a challenging
obstacle that significantly complicates the design and analysis
of ratcheted key-agreement or messaging protocols.

\bigskip

The adversary in ratcheted protocols is quite powerful and can be both
passive and to a certain extend active. This means he has access to
the full message transcript, can expose the states of both
participants, corrupt the states or impersonate users and even choose
the randomness used by the participants. As it is usual in such cases
we assess the advantage of any adversary as part of some key (KIND) or
ciphertext (CIND) indistinguishability game where the adversarial
algorithm $\mathcal{A}$ has access to the send and receive procedures
of both Alice and Bob can expose their states and in the end tries to
distinguish some key from random in the KIND game or decide
which one of two chosen messages corresponds to a given ciphertext
in the CIND game.

\begin{figure}[ht]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.8}{%
    \fbox{%
      \algrenewcommand\textproc{}
      \algrenewcommand\algorithmicprocedure{\textbf{Game}}

      \begin{minipage}{.5\linewidth}
        \begin{algorithmic}[1]
          \Procedure{$\t{KIND}_b^\mathcal{A}$}{}
          \State $(\t{st}_\t{A},\t{st}_\t{B}) \gets$ \Call{Init}{$1^\lambda$}
          \State $b' \gets \mathcal{A}^{\t{RATCH,EXP,TEST}}$
          \State \Return $b'$
          \EndProcedure
        \end{algorithmic}
      \end{minipage}

      \vline

      \algrenewcommand\textproc{}
      \algrenewcommand\algorithmicprocedure{\textbf{Oracle}}

      \begin{minipage}{.5\linewidth}
        \begin{algorithmic}[1]
          \Procedure{TEST}{$\t{P}$}
          \If{$b = 1$}
          \State \Return $k_\t{P}$
          \EndIf
          \State \Return random $\{0,1\}^{|k_\t{P}|}$ 
          \EndProcedure

          \item[] % Blank line.

          \Procedure{EXP}{$\t{P}$}
          \State \Return $\t{st}_\t{P}$ 
          \EndProcedure
       \end{algorithmic}
     \end{minipage}%
    }
  }
  \caption{Generic Key-Indistinguishability Game}
  \label{fig:kind}
\end{figure}

Figure~\ref{fig:kind} depicts a generic KIND game where \texttt{RATCH} denotes
the send or receive procedures for both Alice and Bob, at will callable by the
adversary. We can similarly define the CIND game in figure~\ref{fig:cind}.

\begin{figure}[ht]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.8}{%
    \fbox{%
      \algrenewcommand\textproc{}
      \algrenewcommand\algorithmicprocedure{\textbf{Game}}

      \begin{minipage}{.5\linewidth}
        \begin{algorithmic}[1]
          \Procedure{$\t{CIND}_b^\mathcal{A}$}{}
          \State $(\t{st}_\t{A},\t{st}_\t{B}) \gets$ \Call{Init}{$1^\lambda$}
          \State $b' \gets \mathcal{A}^{\t{RATCH',EXP}}$
          \State \Return $b'$
          \EndProcedure
        \end{algorithmic}
      \end{minipage}

      \vline

      \algrenewcommand\textproc{}
      \algrenewcommand\algorithmicprocedure{\textbf{Oracle}}

      \begin{minipage}{.5\linewidth}
        \begin{algorithmic}[1]
          \Procedure{RATCH'}{$\t{P},m_0,m_1$}
          \State \Return \Call{RATCH}{$\t{P},m_b$}
          \EndProcedure

          \item[] % Blank line.

          \Procedure{EXP}{$\t{P}$}
          \State \Return $\t{st}_\t{P}$ 
          \EndProcedure
       \end{algorithmic}
     \end{minipage}%
    }
  }
  \caption{Generic Ciphertext-Indistinguishability Game}
  \label{fig:cind}
\end{figure}

It is important to note that the way the games are defined is
not sufficient since there exist trivial strategies that make an adversary
succeed. If for example Bob's state is exposed right before he
receives a message then an adversary can easily recover the plaintext
from the message in a messaging protocol or compute the session key
from the message in a key-agreement protocol. It is exactly the
identification of such trivial attacks that pose the greatest
challenge in designing ratcheted protocols implying that the security games
have to be modified to disallow these trivial attacks. Naturally,
the fewer attacks are excluded by the games the securer the overall
protocol becomes. Once the games have been adjusted we can
quantify the advantage of any adversary restricted to some amount queries
and some time complexity as
\[
  \t{Adv}(\mathcal{A}) = \left| \Pr \left[ \t{\{C,K\}IND}_0^\mathcal{A} \rightarrow 1 \right] -
                                \Pr \left[ \t{\{C,K\}IND}_1^\mathcal{A} \rightarrow 1 \right]
                         \right|.
\]



\section{A Brief History of Ratcheted Protocols}
\label{sec:brief-hist-ratch}

As already pointed out the formal analysis of Signal in 2017 marked the
starting point for a slew of ratcheted messaging and key-agreement
protocols. The first protocol was proposed by Bellare et
al.~\cite{bellare2017ratcheted} which established a secure key
exchange protocol for the unidirectional channel that however does not
permit any exposure of the receiver state. Afterwards, Poettering and
R√∂sler~\cite{poettering2018towards} presented a secure bidirectional
key-agreement protocol in the random oracle model. Around the same
time Jaeger and Stepanovs~\cite{jaeger2018optimal} proposed a similar
messaging protocol. To this date, these two protocols achieve the
highest degree of security at the cost of extremely increased running
times.  Later on Durak and Vaudenay~\cite{durak2018bidirectional}
published an efficient bidirectional key-agreement protocol with minor
concessions in terms of security compared to
\cite{poettering2018towards} and \cite{jaeger2018optimal}.  Next in
the line was a messaging protocol by Jost, Maurer and
Mularczyk~\cite{jostefficient} attempting to close the gap between
\cite{durak2018bidirectional} and
\cite{poettering2018towards,jaeger2018optimal}. It offers a higher
security level than \cite{durak2018bidirectional}, though not reaching
\cite{poettering2018towards,jaeger2018optimal}, but is slower in
comparison. The currently last protocol in the line is a construction
from Alwen, Coretti, and Dodis~\cite{alwen2018double}. It takes
a different approach then the other protocol by building an
improved version of the original Signal protocol instead of
coming up with entirely new algorithms. It is an efficient protocol
that does not quite hold up with the other protocols in terms of
security but is the only one that offers immediate decryption,
the ability to decipher messages even if they arrive in
a different order that than they were initially sent in.
In the following sections we will look more closely into all
above described protocols except~\cite{bellare2017ratcheted}.

\section[Poettering and R√∂sler]
{Poettering and R√∂sler~\cite{poettering2018towards}}
\label{sec:poettering-roesler}

This key-agreement protocol was released in the paper
\textit{Asynchronous Ratcheted Key Exchange} in May 2018.
The fact that sets this protocol, and the protocol in the following
section, apart from the others is the notion of \textit{fine-grained}
post-compromise security, meaning that there still remain some
security guarantees concerning the message that directly follows a
state compromise. This kind of security is not supported in
the other protocols where such a message can be fully deciphered
or forged by the adversary. It thus excludes fewer trivial attacks
from their security game, however it does not allow the leakage
or adversarial choice of randomness. The authors conjecture that
fine-grained post-compromise security marks the lower bound
of how many trivial attacks a ratcheted protocol may exclude, hence
the security level achieved in their protocol is optimal.
Surprisingly enough, some heavyweight primitives are required
to reach this lower bound at the cost of an extensive decline
in performance as we will see in the next chapter.

\subsection{Primitives}
\label{sec:primitives}

The protocol proposes a new cryptographic primitive that extends the
functionality of an ordinary key-encapsulation mechanism with an
key update algorithm.
\begin{itemize}
\item \textbf{Key-Updatable Key-Encapsulation Mechanism (ku-KEM).} The primitive
  consists of four procedures, a initial key generation algorithm ($\t{gen}_\t{K}$), an
  key-encapsulation procedure (enc), a corresponding decapsulation procedure (dec) and
  an update procedure for both the public and secret key. Let $\mathcal{PK}$ be
  the public key domain, $\mathcal{SK}$ the secret key domain and $\mathcal{AD}$ the
  associated data domain. We have the following correctness notion, for all
  $(sk_0, pk_0) \in \t{gen}$ and $ad_1,...,ad_n \in \mathcal{AD}$, if
  $sk_i = \t{up}(sk_{i-1},ad_i) \in \mathcal{SK}$ and
  $pk_i = \t{up}(pk_{i-1},ad_i) \in \mathcal{PK}$ for all $i$, then for all
  $(k,c) \in \t{enc}(pk_n)$ we have $\t{dec}(sk_n,c)=k$.
\end{itemize}
In security terms a ku-KEM should satisfy the guarantees of regular
key-encapsulation mechanisms plus some kind of forward security that
protects past keys from state exposures. A ku-KEM can be constructed
out of any hierarchical identity-based encryption scheme
(HIBE)~\cite{gentry2002hierarchical}. Contrary to an ordinate
identity-based encryption scheme where there is a single central
authority handing out secret keys to the users, a HIBE consists
of hierarchical tree structure of many authorities on different levels
such that an authority can access the keys distributed by its children
but its own keys remain inaccessible to any authority on a lower level.
As with ordinary IBE schemes HIBE schemes are usually based on pairing- or
lattice-based cryptography which is far more inefficient than
regular public-key cryptography on elliptic curves.
Next to a HIBE, the protocol requires some other, more standard, primitives.
\begin{itemize}
\item \textbf{One-Time Signature Scheme (OTS).} It consists of three procedures, a initial
  key generation algorithm $\t{gen}_\t{S} \rightarrow \mathcal{SK} \times \mathcal{VK}$,
  a signature algorithm $\t{sgn}: \mathcal{SK} \times \mathcal{M} \rightarrow \Sigma$
  and its corresponding verification algorithm
  $\t{vfy}: \mathcal{VK} \times \mathcal{M} \times \Sigma \rightarrow \{\t{T,F}\}$ with
  $\mathcal{M}$ being the message domain,
  $\mathcal{SK}$ the signing key domain, $\mathcal{VK}$ the verification key domain and
  $\Sigma$ the signature domain.
  We have the following correctness notion, for all $(sgk,vfk) \in \t{gen}_\t{S}$ and
  $m \in \mathcal{M}$ and $\sigma \in \t{sgn}(sgk,m)$ we have $\t{T} = \t{vfy}(vfk,m,\sigma)$.
  We further require strong unforgeability as the security level.
\item \textbf{Random Oracle}. As the protocol is secure in the random oracle H it demands
  a random oracle function H. In practice, H is replaced by a standard hash function.
\end{itemize}

\subsection{Construction}
\label{sec:construction}

Poettering and R√∂sler give three separate constructions in their article.
A unidirectional protocol (URKE), a sesquidirectional construction (SRKE) in which
Bob can reply without establishing a key, finally both URKE and SRKE
are used to create a bidirectional asynchronous key-exchange protocol (BRKE)
with optimal security. The construction is quite involved with long
procedures, figure~\ref{fig:brke} prunes out some parts not necessary for the
analysis of the benchmarks in the next chapter.

% TODO: Complete algorithm.

\begin{figure}[H]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.9}{%
    \fbox{%
      \algrenewcommand\textproc{}
      \algrenewcommand\algorithmicprocedure{\textbf{func}}

      \begin{minipage}{.5\linewidth}
        \begin{algorithmic}[1]
          \Procedure{init}{}
          \For{$u \in \{A,B\}$}
            \State $(sgk_u, vfk_u) \gets \t{gen}_\t{S}$
            \State $(sk_u, pk_u) \gets \t{gen}_\t{K}$
            \State random $K_u \in \{0,1\}^{|\mathcal{K}|}$
            \State $(E^\vdash,E^\dashv) \gets 0; \ (s,r) \gets 0$
            \State $PK_u[0] \gets pk_u; \ SK_u[0] \gets sk_u$
            \State $S_u \gets (PK_{\bar{u}},E,s,vfk_{\bar{u}},K_{\bar{u}})$
            \State $R_u \gets (SK_u,E,r,sgk_u,K_u)$
            \State $ST_u \gets (R_u,S_u)$
          \EndFor
          \State \Return $(ST_A,ST_B)$
          \EndProcedure
        \end{algorithmic}
      \end{minipage}

      \vline

      \algrenewcommand\textproc{}
      \algrenewcommand\algorithmicprocedure{\textbf{Oracle}}

      \begin{minipage}{.5\linewidth}
        \begin{algorithmic}[1]
          \Procedure{RATCH'}{$\t{P},m_0,m_1$}
          \State \Return \Call{RATCH}{$\t{P},m_b$}
          \EndProcedure

          \item[] % Blank line.

          \Procedure{EXP}{$\t{P}$}
          \State \Return $\t{st}_\t{P}$ 
          \EndProcedure
       \end{algorithmic}
     \end{minipage}%
    }
  }
  \caption{Bidirectional Asynchronous Key-Exchange Protocol (BRKE)}
  \label{fig:brke}
\end{figure}

An important concept in the above protocols is the notion epochs
controlled by the $E_S^\vdash,E_S^\dashv$ and $E_R^\vdash,E_R^\dashv$
variables in the state of each user. They basically determine
the complexity of the send and receive procedures due to their
control of the loop bounds.

% TODO Explain epochs.

\section[Jaeger and Stepanovs]{Jaeger and Stepanovs~\cite{jaeger2018optimal}}
\label{sec:jaeger-stepanovs}

This secure messaging protocol was published in the paper
\textit{Optimal Channel Security Against Fine-Grained State Compromise: The Safety of Messaging}
in June 2018 and targets similar a security level as the protocol by
Poettering and R√∂sler although aiming at secure communication instead
of key-exchange and with considering the leakage of randomness.

\subsection{Primitives}
\label{sec:primitives-1}

The protocol, again as in the Poettering and R√∂sler case, uses a HIBE to construct
one of two novel primitives.
\begin{itemize}
\item \textbf{Key-Updatable Public-Key Encryption Scheme (ku-PKE).} The primitive
  consists of five routines. A key generation algorithm
  $\t{PKE.Kg} \rightarrow \mathcal{DK} \times \mathcal{EK}$, an encryption
  procedure $\t{PKE.Enc}: \mathcal{EK} \times \mathcal{M} \rightarrow \mathcal{C}$,
  a corresponding decryption function
  $\t{PKE.Dec}: \mathcal{DK} \times \mathcal{C} \rightarrow \mathcal{M}$ and
  a public-key and private-key update algorithms
  $\t{PKE.UpdEk}: \mathcal{EK} \times \Delta \rightarrow \mathcal{EK}$,
  $\t{PKE.UpdDk}: \mathcal{DK} \times \Delta \rightarrow \mathcal{DK}$, where
  $\mathcal{EK}$ denotes the encryption key domain, $\mathcal{DK}$ the
  decryption key domain, $\mathcal{M}, \mathcal{C}$ the message and
  ciphertext domain respectively. We have the following correctness notion, for all
  $(dk_0, ek_0) \in \t{gen}$ and $\delta_1,...,\delta_n \in \Delta$, if
  $dk_i = \t{PKE.UpdDk}(dk_{i-1},\delta_i)$ and
  $ek_i = \t{PKE.UpdEk}(ek_{i-1},\delta_i)$ for all $i$, then for all
  $c \in \t{enc}(ek_n,m)$ we have $\t{dec}(dk_n,c)=m$.
\end{itemize}

The construction of a ku-PKE is trivially performed out of a HIBE thus if
the HIBE is IND-CCA secure so is the ku-PKE. Furthermore, as with the
ku-KEM, we expect forward security in the case of exposures.
Jaeger and Stepanovs define a second novel primitive for use in the final protocol.
\begin{itemize}
\item \textbf{Key-Updatable Digital Signature Scheme (ku-DSS).} The primitive
  consists of five routines. A key generation algorithm
  $\t{DSS.Kg} \rightarrow \mathcal{SK} \times \mathcal{VK}$, a signing routine
  $\t{DSS.Sign}: \mathcal{SK} \times \mathcal{M} \rightarrow \Sigma$, its
  corresponding verification function
  $\t{DSS.Vrfy}: \mathcal{VK} \times \mathcal{M} \times \Sigma \rightarrow \{\t{T,F}\}$ and
  two public/private-key update routines
  $\t{DSS.UpdVk}: \mathcal{VK} \times \Delta \rightarrow \mathcal{VK}$ and
  $\t{DSS.UpdSk}: \mathcal{SK} \times \Delta \rightarrow \mathcal{SK}$, where
  $\mathcal{VK}$ is the signing key domain, $\mathcal{SK}$ the verification key
  domain and $\mathcal{M}, \Sigma$ are the message and signature domains.
\end{itemize}

In order to construct a ku-DSS we need a forward-secure signature scheme. As
security level we require unforgeability as well as forward-secrecy under
exposures. 

\subsection{Construction}
\label{sec:construction-1}

Figure contains the full secure channel protocol (SCh) based on a collision-resistant
hash function H, a key-updatable public-key encryption scheme PKE and
a key-updatable digital signature scheme.

% TODO: Complete algorithm.

\begin{figure}[H]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.9}{%
    \fbox{%
      \algrenewcommand\textproc{}
      \algrenewcommand\algorithmicprocedure{\textbf{func}}

      \begin{minipage}{.5\linewidth}
        \begin{algorithmic}[1]
          \Procedure{init}{}
          \For{$u \in \{A,B\}$}
            \State $(sgk_u, vfk_u) \gets \t{gen}_\t{S}$
            \State $(sk_u, pk_u) \gets \t{gen}_\t{K}$
            \State random $K_u \in \{0,1\}^{|\mathcal{K}|}$
            \State $(E^\vdash,E^\dashv) \gets 0; \ (s,r) \gets 0$
            \State $PK_u[0] \gets pk_u; \ SK_u[0] \gets sk_u$
            \State $S_u \gets (PK_{\bar{u}},E,s,vfk_{\bar{u}},K_{\bar{u}})$
            \State $R_u \gets (SK_u,E,r,sgk_u,K_u)$
            \State $ST_u \gets (R_u,S_u)$
          \EndFor
          \State \Return $(ST_A,ST_B)$
          \EndProcedure
        \end{algorithmic}
      \end{minipage}

      \vline

      \algrenewcommand\textproc{}
      \algrenewcommand\algorithmicprocedure{\textbf{Oracle}}

      \begin{minipage}{.5\linewidth}
        \begin{algorithmic}[1]
          \Procedure{RATCH'}{$\t{P},m_0,m_1$}
          \State \Return \Call{RATCH}{$\t{P},m_b$}
          \EndProcedure

          \item[] % Blank line.

          \Procedure{EXP}{$\t{P}$}
          \State \Return $\t{st}_\t{P}$ 
          \EndProcedure
       \end{algorithmic}
     \end{minipage}%
    }
  }
  \caption{Secure Channel Protocol (SCh)}
  \label{fig:secure-channel}
\end{figure}

\section[Durak and Vaudenay]
{Durak and Vaudenay~\cite{durak2018bidirectional}}
\label{sec:durak-vaudenay}



\chapter{Benchmarks}
\label{chap:benchmarks}

\chapter{On-Demand BARK}
\label{chap:bark}

\chapter{Conclusion}
\label{chap:conclusion}


\bibliographystyle{plainurl}
\bibliography{bibliography}

\listoffigures

\end{document}
