\documentclass[11pt,a4paper,twoside,openright,bibliography=totoc]{scrbook}

\usepackage{scrhack}
\usepackage{graphicx,xcolor,float}
\usepackage{amssymb,amsmath,array}
\usepackage{setspace,algpseudocode}

\usepackage{tikz}
\usetikzlibrary{positioning,arrows,calc,intersections}

% Color citation, references and links.
\usepackage{url,hyperref}
\hypersetup{
  colorlinks,
  linkcolor={black},
  citecolor={red!70!black},
  urlcolor={blue!70!black}
}
\usepackage[labelfont=bf]{caption} % Bold figure titles.

\renewcommand{\t}{\text} % Shorten \text command.
\parindent0pt            % Do not indent new paragraphs.

\begin{document}
\input{cover/cover}
\tableofcontents

\chapter{Introduction}
\label{chap:introduction}

Messaging has become an ubiquitous resource in the daily lives of
millions of people around the globe through the widespread adoption of
instant messaging applications. The design of protocols which
facilitate securing messaging or key-agreement is faced with a unique
set of challenges, this is due to the longevity of sessions between
communicating parties and the inherently asynchronous notion of
messaging where a participant is both the sender and recipient of
messages and the time a message is sent or received is undefined. In
such a setting the leakage of a state to the adversary is especially
devastating since in a naive protocol it would not only enable him to
recover past messages but also allow future impersonations of the
victim.
Ratcheting has established itself as the go-to technique in
order to mitigate these risks. Akin to its mechanical equivalent the
states are continuously moved forward (updated) without the
possibility of going backwards, i.e.~it should be impossible to
recover past states from the current one.
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.1]{figures/ratchet-icon.eps}
  \caption[Symbolic Ratchet Wheel]{Symbolic Ratchet Wheel\footnotemark}
  \label{fig:ratchet-wheel}
\end{figure}
\footnotetext{\url{https://www.iconfinder.com/icons/328526}}
This further implies that
past message remain secure even in the presence of and adversary who
can expose the state of a participant. The literature labels protocols
that deploy ratchets as \textit{forward-secure}. This technique saw
its inception in 2004 as part of the Off-the-Record messaging
protocol~\cite{borisov2004off}. It only recently gained traction
through the massively popular Signal protocol~\cite{perrin2016double}.
The release of this protocol however predates its first formal
security analysis in 2017~\cite{cohn2017formal}
and since then several novel protocols with various degrees of
security levels have been proposed. Among others
these protocols also attempt the satisfy the notion of \textit{future
secrecy} in which future states and messages remain secure even if the
current state has been leaked. Furthermore, a secure messaging
protocol should be efficient enough to run smoothly even on
computationally inferior devices thus the choice of fast primitives
that do not compromise the promised security levels play a crucial
part in the construction of messaging protocols. Even though on paper
the attained levels of security in these new protocol often only
differ marginally the effects on performance metrics are of a
different kind with sometimes huge differences between the protocols.

% Add some more text here.

\section{Contributions}
\label{sec:contributions}

This project is concerned with surveying and solidifying the
performance differences of six new secure messaging or key-update
protocols that have been proposed during the past two years. In
chapter~\ref{chap:protocols} the notion of secure messaging and
especially ratcheting is formally reviewed before each protocol is
summarized in terms of composition and security levels, then in
chapter~\ref{chap:benchmarks} the protocols are measured and compared
on the basis of several benchmarks.

\section{Circumstances}
\label{sec:circumstances}

This project has been conducted as part of the third master semester optional
semester project in computer science course (CS-596) offered by the
School of Computer and Communications Sciences at EPFL and is credited
with eight points. It was supervised by Doctor Bet√ºl Durak of
the LASEC laboratory.

\chapter{Protocols}
\label{chap:protocols}

As laid out in the introduction the Signal~\cite{perrin2016double}
protocol created and deployed well before the establishment of a
serious secure messaging definition thus it is lacking any form of
formal security proof. The subsequent analysis in 2017~\cite{cohn2017formal}
was then more concerned with proving the security of specific Signal
instances than treating the general case of securing
messaging. Formally, ratcheted messaging attempts to satisfy some
correctness and security notions.


\section{Ratcheted Messaging}
\label{sec:ratcheted-messaging}

For the remainder of this text let Alice and Bob be the communicating
parties through an insecure channel. Alice and Bob take on random
roles throughout their communication and are not necessarily
synchronized meaning that the reception of sent messages may be
delayed to a point where there are already new messages in the channel
travelling in the opposite direction. Note that this does not imply
that messages may be dropped or received in a different order than
they were initially sent in, this will be important later on when
the actual protocols are described.
\begin{figure}[ht]
  \centering
  \input{figures/traffic.tikz} 
  \caption{Example of Ratcheted Traffic}
  \label{fig:traffic}
\end{figure}
Figure~\ref{fig:traffic} shows an example asynchronous traffic
transcript. The initial states of Alice and Bob are created and
distributed by a trusted party, these states are updated with each
send or receive operation. In the case of a key-agreement protocol the
update information corresponding to the created key of the sender
should generate the same key at the receiver when the update message
is received. Analogous, for a messaging protocol where a encrypted
message should be correctly deciphered by the receiver upon
arrival. In figure for example the message sent by Alice at time $t_0$
is only received by Bob at time $t_8$ but should nonetheless produce a
correct key or plaintext regardless of the messages sent by Bob in the
meantime that updated Bob's state.

\section{Ratchet Security}
\label{sec:ratchet-security}

These continuous updates of the states are supposed to be irreversible
such that past states may not be derived from any future state thus
yielding forward security protecting past messages from being
compromised. This was the original goal that ratcheting tried to
achieve. Naively, a ratchet can be constructed through the usage of a
one-way function the simply updates the states of the communicating
parties. In practice, a hash-function would be deployed as a
reasonable alternative with the downside of losing the asynchronous
communication property~\cite{bellare2003forward}. On the other hand if
some randomness is included in the creation of an updated state we can
protect future states from being recreated by an adversary after an
exposure yielding future secrecy or post-compromise security. Another
way is the usage of some key-agreement protocol to schedule the
creation of new states between the parties~\cite{cohn2016post}.  Again
both constructions come at the cost of losing asynchronous
communications. Asynchronous communications is thus a challenging
obstacle that significantly complicates the design and analysis
of ratcheted key-agreement or messaging protocols.

\bigskip

The adversary in ratcheted protocols is quite powerful and can be both
passive and to a certain extend active. This means he has access to
the full message transcript, can expose the states of both
participants, corrupt the states or impersonate users and in some
cases even choose the randomness used by the participants. As it is
usual in such cases we assess the advantage of any adversary as part
of some key (KIND) or ciphertext (CIND) indistinguishability game
where the adversarial algorithm $\mathcal{A}$ has access to the send
and receive procedures of both Alice and Bob can expose their states
and in the end tries to distinguish some key from random in the KIND
game or decide which one of two chosen messages corresponds to a given
ciphertext in the CIND game.
Figure~\ref{fig:kind} depicts a generic KIND game where \texttt{RATCH} denotes
the send or receive procedures for both Alice and Bob, at will callable by the
adversary. We can similarly define the CIND game in figure~\ref{fig:cind}.
It is important to note that the way the games are defined is
not sufficient since there exist trivial strategies that make an adversary
succeed. If for example Bob's state is exposed right before he
receives a message then an adversary can easily recover the plaintext
from the message in a messaging protocol or compute the session key
from the message in a key-agreement protocol. It is exactly the
identification of such trivial attacks that pose the greatest
challenge in designing ratcheted protocols implying that the security games
have to be modified to disallow these trivial attacks. Naturally,
the fewer attacks are excluded by the games the securer the overall
protocol becomes. Once the games have been adjusted we can
quantify the advantage of any adversary restricted to some amount queries
and some time complexity as
\[
  \t{Adv}(\mathcal{A}) = \left| \Pr \left[ \t{\{C,K\}IND}_0^\mathcal{A} \rightarrow 1 \right] -
                                \Pr \left[ \t{\{C,K\}IND}_1^\mathcal{A} \rightarrow 1 \right]
                         \right|.
\]

\begin{figure}[ht]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.8}{%
    \fbox{%
      \input{figures/kind.tex}
    }
  }
  \caption{Generic Key-Indistinguishability Game}
  \label{fig:kind}
\end{figure}

\begin{figure}[ht]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.8}{%
    \fbox{%
      \input{figures/cind.tex}
    }
  }
  \caption{Generic Ciphertext-Indistinguishability Game}
  \label{fig:cind}
\end{figure}

\section{A Brief History of Ratcheted Protocols}
\label{sec:brief-hist-ratch}

As already pointed out the formal analysis of Signal in 2017 marked the
starting point for a slew of ratcheted messaging and key-agreement
protocols. The first protocol was proposed by Bellare et
al.~\cite{bellare2017ratcheted} which established a secure key
exchange protocol for the unidirectional channel that however does not
permit any exposure of the receiver state. Afterwards, Poettering and
R√∂sler~\cite{poettering2018towards} presented a secure bidirectional
key-agreement protocol in the random oracle model. Around the same
time Jaeger and Stepanovs~\cite{jaeger2018optimal} proposed a similar
messaging protocol. To this date, these two protocols achieve the
highest degree of security at the cost of extremely increased running
times.  Later on Durak and Vaudenay~\cite{durak2018bidirectional}
published an efficient bidirectional key-agreement protocol with minor
concessions in terms of security compared to
\cite{poettering2018towards} and \cite{jaeger2018optimal}.  Next in
the line was a messaging protocol by Jost, Maurer and
Mularczyk~\cite{jostefficient} attempting to close the gap between
\cite{durak2018bidirectional} and
\cite{poettering2018towards,jaeger2018optimal}. It offers a higher
security level than \cite{durak2018bidirectional}, though not reaching
\cite{poettering2018towards,jaeger2018optimal}, but is slower in
comparison. The currently last protocol in the line is a construction
from Alwen, Coretti, and Dodis~\cite{alwen2018double}. It takes
a different approach then the other protocol by building an
improved version of the original Signal protocol instead of
coming up with entirely new algorithms. It is an efficient protocol
that does not quite hold up with the other protocols in terms of
security but is the only one that offers immediate decryption,
the ability to decipher messages even if they arrive in
a different order that than they were initially sent in.
In the following sections we will look more closely into all
above described protocols except~\cite{bellare2017ratcheted}.

\section{Notation}
\label{sec:notation}

All the protocols depicted in the following figures are as closely
as possible modelled in respect to the original prints in their respective
papers. The pseudo-code should be self-contained but there are nonetheless
some special symbols. We let $\perp$ denote the \texttt{null} symbol.
$||$ represents the concatenation of two byte arrays. An empty
array is described by $[\cdot]$. Ellipses in the array selector
$A[...,i]$ are used to
denote an operation on multiple array elements and last but not least
$\leftarrow$ is the assignment operator.

\section[Poettering and R√∂sler]
{Poettering and R√∂sler~\cite{poettering2018towards}}
\label{sec:poettering-roesler}

This key-agreement protocol was released in the paper
\textit{Asynchronous Ratcheted Key Exchange} in May 2018.
The fact that sets this protocol, and the protocol in the following
section, apart from the others is the notion of post-impersonation security or
also called fine-grained post-compromise security,
meaning that there still remain some security guarantees concerning
messages that follow a successful
impersonation attempt. Post-impersonation security can be further divided
into authenticity and confidentiality.
\begin{itemize}
\item \textbf{Post-Impersonation Authentication.} Assume the adversary
  managed to inject a message to Bob thus is impersonating Alice.
  Post-impersonation authenticity makes sure that any further message
  from Bob will be rejected by Alice. This should even hold if
  Bob's state is compromised after the injection. Chain-hashing
  the communication transcript is a simple way to reject messages from
  Bob after an injection for the case where Bob's state has not
  been compromised. As we will see in section~\ref{sec:durak-vaudenay}
  a similar notion called recover security is one of the corner stones
  of the protocol by Durak and Vaudenay. However, maintaining authenticity
  after an injection with an additional state leakage is another level
  and seems to require heavy primitives as deployed in this protocol.
\item \textbf{Post-Impersonation Confidentiality.} Again assume
  that the adversary managed to have an injected message accepted by Bob,
  post-impersonation confidentiality ensures that future messages remain
  confidential even if Bob's state is exposed after the injection.
\end{itemize}
In section~\ref{sec:jost-maur-mularczyk} we will see a protocol
that comes close to providing full post-impersonation security
if some properties are satisfied while only relying on
public-key cryptography instead of the extremely inefficient
primitives in this protocol furthermore this protocol
does not consider the leakage of random coins contrary to
the other protocol that at least offer some resistance against
this kind of exposure. The authors conjecture that
post-impersonation security marks the lower bound
of how many attacks a ratcheted protocol may permit, hence
the security level achieved in their protocol is optimal.

\subsection{Primitives}
\label{sec:primitives}

The protocol proposes a new cryptographic primitive that extends the
functionality of an ordinary key-encapsulation mechanism with an
key update algorithm and is the tool with which post-impersonation
security is reached.
\begin{itemize}
\item \textbf{Key-Updatable Key-Encapsulation Mechanism (ku-KEM).} The primitive
  consists of four procedures, a initial key generation algorithm \texttt{Gen}, an
  key-encapsulation procedure \texttt{Enc}, a corresponding decapsulation
  procedure \texttt{Dec} and
  an update procedure for both the public \texttt{UpdPk} and secret key \texttt{UpdSk}.
  \begin{align*}
    \texttt{Gen} & : \ \rightarrow \mathcal{SK} \times \mathcal{VK} \\
    \texttt{Enc} & : \mathcal{PK} \rightarrow \mathcal{K} \times \mathcal{C} \\ 
    \texttt{Dec} & : \mathcal{SK} \times \mathcal{C} \rightarrow \mathcal{K} \\
    \texttt{UpdPk} & : \mathcal{PK} \times \Delta \rightarrow \mathcal{PK} \\
    \texttt{UpdSk} & : \mathcal{SK} \times \Delta \rightarrow \mathcal{SK}
  \end{align*}
  $\mathcal{PK}$ is the public key domain, $\mathcal{SK}$ is the secret key domain,
  $\mathcal{AD}$ is the associated data domain and $\Delta$ is
  the update information domain.
\end{itemize}
In security terms a ku-KEM should satisfy the guarantees of regular
key-encapsulation mechanisms in addition to forward security that
protecting past keys from state exposures. A ku-KEM can be constructed
out of any hierarchical identity-based encryption scheme
(HIBE)~\cite{gentry2002hierarchical}. Contrary to an ordinate
identity-based encryption scheme where there is a single central
authority handing out secret keys to the users, a HIBE consists
of hierarchical tree structure of many authorities on different levels
such that an authority can access the keys distributed by its children
but its own keys remain inaccessible to any authority on a lower level.
As with ordinary IBE schemes HIBE schemes are usually based on pairing- or
lattice-based cryptography which are far more inefficient than
regular public-key cryptography on elliptic curves.
Next to a HIBE construction, the protocol further needs a forward secure
signature scheme DS with the functions (\texttt{Gen,Sign,Verify})
and a random oracle \texttt{H}.

\subsection{Construction}
\label{sec:construction}

Poettering and R√∂sler give three separate constructions in their article.
A unidirectional protocol (URKE), a sesquidirectional construction (SRKE) in which
Bob can reply without establishing a key, finally both URKE and SRKE
are used to create a bidirectional asynchronous key-exchange protocol (BRKE)
with optimal security. The construction is quite involved with long
procedures, figure~\ref{fig:brke} prunes out some parts not necessary for the
analysis of the benchmarks in the next chapter. The protocol proceeds
in epochs indicated by the $(E_S^\vdash,E_S^\dashv)$ and $(E_R^\vdash,E_R^\dashv)$
variables that steer the creation of encapsulations and key updates.
Prolonged periods of unidirectional traffic will enlarge the
difference between $(E_R^\vdash,E_R^\dashv)$ for the sending
party and $(E_S^\vdash,E_S^\dashv)$ for the receiving party, when
the direction of traffic changes both parties will perform
multiple iterations of key updates to equalize those counters again.

\begin{itemize}
\item \textbf{Init.} Two sets of ku-KEM, DS and hashing keys are generated
  and distributed to the participants. Furthermore, each user has a counter
  for sent messages $s$ and for received messages $r$ next to the epoch
  counters unified under the variable $E$. Due to epochs the ku-KEM keys
  are stored in arrays (SK,PK) with $(L_S,L_R)$ storing the transcript
  of sent and received messages.
\item \textbf{Send}. Each send operation generates a new set of
  ku-KEM and DS keys where the encapsulation key $pk^*$ and the
  signature verification key $sk^*$ are sent along the ciphertext
  together with a signature $\sigma$ and the current $E_S^\dashv$ epoch
  counter. The random oracle creates the session key as well as yet another
  ku-KEM public key and updates the hashing key.
\item \textbf{Receive.} The receive operation mirrors the
  operations in the send function. With the addition
  of updating the ku-KEM keys in case the epoch counters have diverged.
  Note that in both the send and receive routines there is some light
  housekeeping to delete transcripts and ku-KEM keys of past
  epochs.
\end{itemize}

\begin{figure}[p]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.9}{%
    \fbox{%
      \input{figures/brke.tex}
    }
  }
  \caption{Bidirectional Asynchronous Key-Exchange Protocol (BRKE)}
  \label{fig:brke}
\end{figure}

\clearpage

\section[Jaeger and Stepanovs]
{Jaeger and Stepanovs~\cite{jaeger2018optimal}}
\label{sec:jaeger-stepanovs}

This secure messaging protocol was published in the paper
\textit{Optimal Channel Security Against Fine-Grained State Compromise: The Safety of Messaging}
in June 2018 and targets similar a security level as the protocol by
Poettering and R√∂sler although aiming at secure communication instead
of key-exchange and with the addition consideration of leaking the random coins.
This means that the protocol also achieves post-impersonation security
at the cost of an increased running time due to the usage
of inefficient primitives.

\subsection{Primitives}
\label{sec:primitives-1}

The protocol, again as in the Poettering and R√∂sler case, uses a HIBE to construct
one of two novel primitives.
\begin{itemize}
\item \textbf{Key-Updatable Public-Key Encryption Scheme (ku-PKE).} The primitive
  consists of five routines. A key generation algorithm \texttt{PKE.Gen},
  an encryption procedure \texttt{PKE.Enc}, a corresponding decryption
  function \texttt{PKE.Dec} and two update routines one for the
  encryption key \texttt{PKE.UpdEk} and one for the decryption key \texttt{PKE.UpdDk}.
  \begin{align*}
    \texttt{PKE.Kg} & : \ \rightarrow \mathcal{DK} \times \mathcal{EK} \\
    \texttt{PKE.Enc} & : \mathcal{EK} \times \mathcal{M} \rightarrow \mathcal{C} \\
    \texttt{PKE.Dec} & : \mathcal{DK} \times \mathcal{C} \rightarrow \mathcal{M} \\
    \texttt{PKE.UpdEk} & : \mathcal{EK} \times \Delta \rightarrow \mathcal{EK} \\
    \texttt{PKE.UpdDk} & : \mathcal{DK} \times \Delta \rightarrow \mathcal{DK}
  \end{align*}
  $\mathcal{EK}$ denotes the encryption key domain, $\mathcal{DK}$ the
  decryption key domain, $\mathcal{M}, \mathcal{C}$ the message and
  ciphertext domain respectively and $\Delta$ is the update information domain.
\end{itemize}

The construction of a ku-PKE is trivially performed out of a HIBE thus if
the HIBE is IND-CCA secure so is the ku-PKE. Furthermore, as with the
ku-KEM, we expect forward security in the case of exposures.
Jaeger and Stepanovs define a second novel primitive for use in the final protocol.
\begin{itemize}
\item \textbf{Key-Updatable Digital Signature Scheme (ku-DSS).} The primitive
  consists of five routines. A key generation algorithm
  \texttt{DS.Gen}, a signing routine \texttt{DS.Sign}, its corresponding
  verification function \texttt{DS.Verify} and two key update routines
  one for the signing key \texttt{DS.UpdSk} and one for the verification
  key \texttt{DS.UpdVk}.
  \begin{align*}
    \texttt{DS.Gen} & \  \rightarrow \mathcal{SK} \times \mathcal{VK} \\
    \texttt{DS.Sign} & : \mathcal{SK} \times \mathcal{M} \rightarrow \Sigma \\
    \texttt{DS.Verify} & : \mathcal{VK} \times \mathcal{M} \times \Sigma \rightarrow \{0,1\} \\
    \texttt{DS.UpdSk} & : \mathcal{SK} \times \Delta \rightarrow \mathcal{SK} \\
    \texttt{DS.UpdVk} & : \mathcal{VK} \times \Delta \rightarrow \mathcal{VK}
  \end{align*}
  $\mathcal{VK}$ is the signing key domain, $\mathcal{SK}$ the verification key
  domain, $\mathcal{M}, \Sigma$ are the message and signature domains and
  $\Delta$ is the update information domain.
\end{itemize}

In order to construct a ku-DSS we need a forward-secure signature scheme. As
security level we require unforgeability as well as forward-secrecy under
exposures. 

\subsection{Construction}
\label{sec:construction-1}

Figure~\ref{fig:secure-channel} depicts the secure channel
protocol (SCh) based on a collision-resistant
hash function H, a key-updatable public-key encryption scheme PKE and
a key-updatable digital signature scheme DS. Some non-critical
control-branches have been omitted.
\begin{itemize}
\item \textbf{Init.} Two sets of ku-PKE and ku-DSS are generated
  distributed to each user next to shared hashing key $hk$. Furthermore,
  each user has counter of sent messages $s$, a counter for received messages
  $r$ and a counter for sent messages that were received by the partner
  $r^\t{ack}$. Both users keep chain-hashes of sent $T_\t{S}$ and received
  messages $T_\t{R}$.
\item \textbf{Send.} Each send operation generates new ku-DSS key pair
  $(sk',vk')$ and a new ku-PKE key pair $(ek',dk')$. $vk'$ and $ek'$ are sent
  along the ciphertext as associated data. The new ku-PKE decryption keys are accumulated
  in the $dk$ array. Note that updated encryption keys $ek'$ are used to
  encrypt the message but $ek'$ is then discarded at the end of the function.
\item \textbf{Receive.} The receive function mirrors the operations
  performed during sending. At every call the signing key $sk$ is updated
  thus when this key is then used in a sending operation the
  partner has to perform a corresponding loop of \texttt{DSS.UpdVk}
  call to equalize its verification key again these updates
  are not kept in memory upon exiting the functions.
\end{itemize}

\begin{figure}[p]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.9}{%
    \fbox{%
      \input{figures/sch.tex}
    }
  }
  \caption{Secure Channel Protocol (SCh)}
  \label{fig:secure-channel}
\end{figure}

\clearpage

\section[Durak and Vaudenay]
{Durak and Vaudenay~\cite{durak2018bidirectional}}
\label{sec:durak-vaudenay}

This key-agreement protocol was published in the paper
\textit{Bidirectional Asynchronous Ratcheted Key Agreement without
Key-Update Primitives}, short BARK, in September 2018. It was the first approach to
create a simple but efficient protocol without the use of slow,
hand-tailored primitives at the cost of not supporting fine-grained
post-compromise security. Furthermore, the protocol explicitly spells
out the trivial attacks, although disallowing more than the previous
two protocols, and bundles them in form a \textit{cleanness-predicate}
which greatly simplifies the security games and its accompanying
security proofs. The authors also introduce a new notion called
recover security, already mentioned in section~\ref{sec:poettering-roesler}
as part of post-impersonation security,
stating that if the adversary manages to inject a message to Bob
then any further message from Alice to Bob will be rejected.
Such an injection can happen after Alice's state has been leaked.
Clearly, if the participants simply recover from the exposure both they may
never detect that there was an active impersonation attack in place,
the protocol thus advocates to detect such forgeries right after a
state exposure with a following injection and immediately cut the communication as a
consequence. Such recover security can easily be achieved with a
collision resistant hash function that chain hashes the entire
communication transcript. As the cherry on cake the papers shows that
a weaker unidirectional version of the protocol already implies
public-key cryptography which essentially shatters any hopes of
achieving similar levels of security with symmetric primitives.

\subsection{Primitives}
\label{sec:primitives-2}

As already indicated the protocol does not deploy any intricate
cryptographic primitives. Next to the hash function it combines a
public-key encryption scheme and a digital signature scheme to
a signcryption algorithm.
\begin{itemize}
\item \textbf{Signcryption Scheme (SC).} This primitive consists of four routines,
  two key generation algorithms one creating the PKE keys \texttt{PKE.Gen}
  $\t{Gen}_\t{R} \rightarrow \mathcal{SK}_\t{R} \times \mathcal{PK}_\t{R}$
  for the creation of the DS keys \texttt{DS.Gen}. Furthermore,
  there is an encryption procedure \texttt{Enc} and a corresponding
  decryption procedure \texttt{Dec}.
  \begin{align*}
    \texttt{PKE.Gen} & : \ \rightarrow \mathcal{SK}_\t{R} \times \mathcal{PK}_\t{R} \\
    \texttt{DS.Gen} & : \ \rightarrow \mathcal{SK}_\t{S} \times \mathcal{PK}_\t{S} \\
    \texttt{Enc} & : \mathcal{SK}_\t{S} \times \mathcal{PK}_\t{R} \times
                   \rightarrow \mathcal{C} \\
    \texttt{Dec} & : \mathcal{SK}_\t{R} \times \mathcal{PK}_\t{S}
  \mathcal{C} \times \mathcal{AD} \rightarrow \mathcal{M}
  \end{align*}
  $(\mathcal{PK}_\t{R},\mathcal{SK}_\t{R})$ are the PKE key domains,
  $(\mathcal{PK}_\t{S},\mathcal{SK}_\t{S})$ are the DS key domains, $\mathcal{AD}$
  is the associated data domain and $(\mathcal{M}, \mathcal{C})$ are
  the message and ciphertext domain respectively.
\end{itemize}

A signcryption scheme can be constructed by naively chaining a DSS and PKE scheme
such that $\t{Enc}(sk_S,pk_R,ad,m) = \t{PKE.Enc}(pk_R,m || \t{DSS.Sign}(sk_S,ad || m))$.

\subsection{Construction}
\label{sec:construction-2}

Similar to the protocol by Poettering and R√∂sler the BARK protocol is
constructed via a smaller unidirectional protocol. Figure~\ref{fig:uni-arcad}
shows the unidirectional ARCAD messaging protocol that is KIND-secure but
does not offer recover security. In the ARCAD protocol with each send operation
there is an exchange of fresh signcryption key pairs.

\begin{figure}[H]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.9}{%
    \fbox{%
      \input{figures/arcad.tex}
    }
  }
  \caption{Unidirectional ARCAD Protocol}
  \label{fig:uni-arcad}
\end{figure}

The composition of two separate uniARCAD instances yields
the full BARK protocol as shown in figure~\ref{fig:bark}.
\begin{itemize}
\item \textbf{Init.} Two uniARCAD instances are generated and
  distributed to the participants alongside a hashing key $hk$.
  The Hsent and Hreceived chain-hash variable meant to record
  the hash of all sent and recorded messages are initialized
  to null.
\item \textbf{Send.} Each send operation creates a fresh
  signcryption key pair that is the onion encrypted alongside
  the chosen session key $k$. The onion encryption itself
  creates new signcryption states of which only the one from
  the inner-most layer is kept. The onion has many layers when
  after a long period of unidirectional messages the direction
  of traffic changes after this message the participants will
  then have sync-up again thus further messages will then
  have again few onion layers. Note that the chain-hash
  of all sent and received messages is to ensure recover security.
\item \textbf{Receive.} The operation during a receive call
  mirror the ones in the send routine. The receiver extracts
  the signcryption sender state from the ciphertext and appends
  it to its array of sender states. When the receiver decides
  to reply all these accumulated states will be used in the
  onion encryption. Furthermore, old receiver states are
  erased from memory at the end of the function.
\end{itemize}

\begin{figure}[p]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.9}{%
    \fbox{%
      \input{figures/bark.tex}
    } 
  }
  \caption{BARK Protocol}
  \label{fig:bark}
\end{figure}

\clearpage

\section[Jost, Maurer and Mularczyk]
{Jost, Maurer and Mularczyk~\cite{jostefficient}}
\label{sec:jost-maur-mularczyk}

This secure messaging protocol was published in the paper
\textit{Efficient Ratcheting: Almost-Optimal Guarantees for Secure Messaging}
in early October 2018. It offers near-optimal security guarantees similar
to the protocols by Poettering, R√∂sler and Jaeger, Stepanovs while
deploying lighter primitives than the latter two. Effectively, the protocol
only excludes some special cases of post-impersonation security,
for example it requires that the message directly before
the injection remains confidential in order to maintain
post-impersonation authenticity and confidentiality. This choice
enabled to authors to only rely on public-key cryptography in
the construction of their primitives. The protocol further
offers recover security as defined by Durak and Vaudenay.
It thus offers a slightly higher security level than the protocol by
Durak and Vaudenay. It also decouples the leakage of random coins
from state exposures with all security proofs being in the random
oracle model.

\subsection{Primitives}
\label{sec:primitives-3}

The protocol proposes several novel cryptographic primitives that can all be
mounted by regular public-key key cryptosystems to extend them
with key-update routines.
\begin{itemize}
\item \textbf{Key-Updating Signature (KuSig).} This primitive consists of
  three routines. A key generation algorithm \texttt{Gen}, a signing function
  \texttt{Sign}, and its corresponding verification procedure.
  \begin{align*}
    \texttt{Gen} & : \ \rightarrow \mathcal{VK} \times \mathcal{SK} \\
    \texttt{Sign} & : \mathcal{SK} \times \mathcal{M} \rightarrow \mathcal{SK} \times \Sigma \\
    \texttt{Verify} & : \mathcal{VK} \times \mathcal{M} \times \Sigma
             \rightarrow \mathcal{VK} \times \{0,1\}
  \end{align*}
  $\mathcal{VK}$ is the verification key domain, $\mathcal{SK}$ the signing
  key domain and $(\mathcal{M},\Sigma)$ are the message and the signature domains
  respectively.
\end{itemize}

As the security level we require resistance against universal forgeries
with added forward security in case of state exposures.

\begin{itemize}
\item \textbf{Secretly Key-Updatable Public-Key Encryption (SkuPke).} This
  primitive consists of six routines. A key generation algorithm \texttt{Gen},
  an encryption routine \texttt{Enc} and its corresponding decryption function
  \texttt{Dec}. Furthermore, there is an algorithm that generate key update
  information \texttt{UpdGen} that feeds two key update procedures
  one for the encryption key \texttt{UpdEk} and one for the
  decryption key \texttt{UpdDk}.
  \begin{align*}
    \texttt{Gen} & : \rightarrow \mathcal{EK} \times \mathcal{DK} \\
    \texttt{Enc} & : \mathcal{EK} \times \mathcal{M} \rightarrow \mathcal{C} \\
    \texttt{Dec} & : \mathcal{DK} \times \mathcal{C} \rightarrow \mathcal{M} \\
    \texttt{UpdGen} & : \ \rightarrow \mathcal{UE} \times \mathcal{UD} \\
    \texttt{UpdEk} & : \mathcal{UE} \times \mathcal{EK} \rightarrow \mathcal{EK} \\
    \texttt{UpdDk} & :  \mathcal{UD} \times \mathcal{DK} \rightarrow \mathcal{DK}
  \end{align*}
  $(\mathcal{EK},\mathcal{DK})$ denote the encryption/decryption key domains,
  $\mathcal{M},\mathcal{C}$ denote the message/ciphertext domains, $\mathcal{UE}$
  is the encryption key update information domain and $\mathcal{UD}$ is the
  decryption key update information domain.
\end{itemize}

The intuition behind this primitive is that the key pair can be
updated independently with update information not linked to any
key where the update information for the encryption key can be freely
exposed while the update information for the decryption should
remain hidden and only change hands through a back-channel.
This scheme can be constructed out of a vanilla components
of the ElGamal cryptosystem. The SkuPke scheme serves to
create another primitive.
\begin{itemize}
\item \textbf{Healable And Key-Updating Public-Key Encryption (HkuPke).} This
  primitive consists of five routines. A key generation algorithm \texttt{Gen},
  an encryption routine \texttt{Enc} and the respective decryption function
  \texttt{Dec}. Furthermore, there are two key update algorithms one
  for the encryption key \texttt{BcUpEk} and one for the decryption key \texttt{BcUpDk}.
  \begin{align*}
    \texttt{Gen} & : \ \rightarrow \mathcal{EK} \times \mathcal{DK} \\
    \texttt{Enc} & : \mathcal{EK} \times \mathcal{M} \times \mathcal{AD}
                   \rightarrow \mathcal{C} \\
    \texttt{Dec} & : \mathcal{DK} \times \mathcal{C} \times \mathcal{AD}
                   \rightarrow \mathcal{M} \\
    \texttt{BcUpEk} & : \mathcal{EK} \times \Delta \rightarrow \mathcal{EK} \\
    \texttt{BcUpDk} & : \mathcal{DK} \times \Delta \rightarrow \mathcal{DK}
  \end{align*}
  $\mathcal{EK}$ being the encryption key domain, $\mathcal{DK}$ the decryption
  key domain, $\mathcal{M}$, is the message domain, $\mathcal{C}$ the ciphertext
  domain, $\mathcal{AD}$ is the associated data domain
  and $\Delta$ is the update information domain.
\end{itemize}

The purpose of the HkuPke scheme is similar to the SkuPke scheme with the difference
that we now still allow the decryption of messages for any arbitrary sequence
of \texttt{BcUpDk} calls where only a prefix of the used update information
has been used in \texttt{BcUpEk} calls. The receiver can thus
instigate key updates via a back-channel to start the healing process.
Finally, the protocol also needs standard digital signature scheme Sig
with the functions (\texttt{Gen,Sign,Verify}) and some collision-resistant
hash function H.

\subsection{Construction}
\label{sec:construction-3}

Figure~\ref{fig:secmsg} shows the SecMsg protocol based on a healable and key-updating
public-key encryption scheme HkuPke, a key-updatable signature scheme KuSig,
a regular digital signature scheme Sig and a collision-resistant hash function H.
\begin{itemize}
\item \textbf{Init.} The initialization routine creates two sets of key pairs
  for each primitive and distributes them to the participants. It further
  initializes a sent message counter $s$, a received messages counter $r$,
  an acknowledged message counter $s_\t{ack}$ passed alongside
  each ciphertext to indicate the number of already received messages, an array
  of signature verification keys $VK^\t{eph}$, a variable $tr$ holding the chain-hash
  of all received ciphertexts and finally an array $TR$ for accumulating
  the chain-hash of all sent ciphertexts.
\item \textbf{Send.} The send operation starts of with creating two signature
  key pairs one for signing the following message $(sk_2^\t{eph},vk_2^\t{eph})$
  and one for the partner sign his response $(sk_1^\t{eph},vk_1^\t{eph})$ thus
  implying that $sk_1^\t{eph}$ is part of the ciphertext and $vk_2^\t{eph}$ is
  sent alongside the ciphertext. The sender then updates his
  HkuPke decryption key $dk$ and includes the update information $upd$
  in the sent message. After encrypting the message with the mentioned
  side information the resulting ciphertext is signed twice once
  by the KuSig and once by the regular signature scheme. The two signatures
  and the ciphertext are sent to the partner. The two signatures are
  necessary to provide post-impersonation authentication while
  maintaining post-compromise
  security. Note the first message of a cascade of message to be sent
  without any replies in between will use the signing key provided in
  the last received message the following messages in the cascade
  will use the keys generated at the beginning of the procedure. This
  is the reason why $vk_1^\t{eph}$ is stored in an array.
\item \textbf{Receive.} The receive routine mirrors the operations performed
  during the send call. This means it unpacks the signature keys
  $(vk_\t{msg}^\t{eph},sk_\t{msg}^\t{eph})$ and retrieves the plaintext while
  updating its HkuPke encryption key. Further note that the chain-hash
  of the communication transcript is included in both signature ensuring
  that messages of a hijacked participants are rejected.
\end{itemize}

\begin{figure}[p]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.9}{%
    \fbox{%
      \input{figures/secmsg.tex}
    } 
  }
  \caption{Secure Messaging Protocol}
  \label{fig:secmsg}
\end{figure}

\clearpage

\section[Alwen, Coretti and Dodis]
{Alwen, Coretti and Dodis~\cite{alwen2018double}}
\label{sec:alwen-coretti-dodis}

This secure messaging protocol was published in the paper \textit{The
Double Ratchet: Security Notions, Proofs, and Modularization for the
Signal Protocol} in late October 2018. The protocol is an attempt to
modularize the existing Signal algorithm using simpler cryptographic
primitives. It is further the only protocol that offers immediate
decryption thus possessing message-loss and message-reorder resilience
while using mostly symmetric-key cryptography to achieve forward and
post-compromise security. This makes the protocol faster than the
other protocols that almost exclusively rely on public-key primitives.
Due to this the protocol offers the weakest security level especially
during unidirectional traffic where the states are not ratcheted hence
compromising post-compromise security. Recall that the term
\textit{double ratchet} was used by Signal to denote the one ratchet
providing forward-security and the other which provides post-compromise
security.


\subsection{Primitives}
\label{sec:primitives-4}

The protocol proposes three novel building blocks. The first provides
the protocol with forward-security and the immediate decryption
property.
\begin{itemize}
\item \textbf{Forward-Secure Authenticated Encryption with Associated Data (FS-AEAD).}
  This primitives consists of four routines, two state generation functions
  (\texttt{FS-Init-S},\texttt{FS-Init-R})
  one for the sender key and one for the receiver key, a send routine \texttt{FS-Send}
  and its corresponding receive function \texttt{FS-Rcv}. We have the following
  function headers
  \begin{align*}
    \t{FS-Init-S} & : \mathcal{K} \rightarrow \mathcal{V}_S \\
    \t{FS-Init-R} & : \mathcal{K} \rightarrow \mathcal{V}_R \\
    \t{FS-Send} & : \mathcal{V}_S \times \mathcal{AD} \times \mathcal{M}
                                \rightarrow \mathcal{V}_S \times \mathcal{C} \\
    \t{FS-Rcv} & : \mathcal{V}_R \times \mathcal{AD} \times \mathcal{C}
                                \rightarrow \mathcal{V}_R \times \mathcal{C}.
  \end{align*}
  $\mathcal{K}$ is the key domain, $\mathcal{V}_S$ is the sender state domain,
  $\mathcal{V}_R$ is the receiver state domain, $\mathcal{AD}$
  is the associated data domain, $\mathcal{M}$ is the message domain and
  $\mathcal{C}$ is the ciphertext domain. The correctness notion is
  straightforward with the added requirement of immediate decryption.
\end{itemize}

A FS-AEAD can be constructed out of a regular AEAD scheme and a pseudo-random
number generator. The second primitive takes care of the scheduling
of new keys for post-compromise security.
\begin{itemize}
\item \textbf{Continuous Key Agreement (CKA).} This primitive consists
  of four routines, two state generation functions (\texttt{CKA-Init-S}, \texttt{CKA-Init-R})
  one for the sender and one for the receiver, a send routine \texttt{CKA-S} and
  its corresponding receive function \texttt{CKA-R}. We have the following
  function headers
  \begin{align*}
    \texttt{CKA-Init-S} & : \mathcal{K} \rightarrow \mathcal{V}_A \\
    \texttt{CKA-Init-R} & : \mathcal{K} \rightarrow \mathcal{V}_B \\
    \texttt{CKA-S} & : \mathcal{V}_A \rightarrow
                \mathcal{V}_A \times \mathcal{T} \times \mathcal{I} \\
    \texttt{CKA-R} & : \mathcal{V}_B \times \mathcal{T} \rightarrow
                \mathcal{V}_B \times \mathcal{I}.
  \end{align*}
  $\mathcal{K}$ is the key domain, $\mathcal{V}_A$ is state domain of Alice,
  $\mathcal{V}_B$ is the state domain of Bob, $\mathcal{T}$
  is message domain and $\mathcal{I}$ is the domain of the generated key.
  The CKA is alternating in its nature meaning that if Alice instigated
  the first key exchange the following one must be started by Bob thus
  the participants switch the roles after each exchange. By the
  above definition, Alice has to send the first message.
\end{itemize}

A CKA scheme can be constructed out of a generic key-encapsulation
mechanism or using the Diffie-Hellman assumption. The last
primitive in the group is a blend between a pseudo-random function
and a pseudo-random number generator.
\begin{itemize}
\item \textbf{PRF-PRNG.} This primitive consists of two routines.
  An initialization algorithm \texttt{P-Init} and an update function \texttt{P-Up}
  with the following function headers
  \begin{align*}
    \t{P-Init} & : \mathcal{K} \rightarrow \Sigma \\
    \t{P-Up} & : \Sigma \times \mathcal{I} \rightarrow \Sigma \times \mathcal{I}.
  \end{align*}
  $\mathcal{K}$ is the key domain, $\Sigma$ is the state domain and
  $\mathcal{I}$ is the update information domain.
\end{itemize}

The intuition behind a PRF-PRNG is that on input some update information
it refreshes its state and yields a pseudo-random output exactly like
a normal PRNG, furthermore a PRF-PRNG behaves like a PRF in the sense
that multiple derived outputs are indistinguishable from random
values. A PRF-PRNG can be constructed out of HKDF or from
a generic PRNG and PRF functions.

\subsection{Construction}
\label{sec:construction-4}

Figure~\ref{fig:double-ratchet} shows the double ratchet protocol by
Alwen, Coretti and Dodis. For simplicity only the algorithms
for one participant are specified but they are analogous for
the partner. Similar to the protocol by Poettering and R√∂sler
the double ratchet protocol also proceeds in epochs where
even epochs are reserved for Alice to send and odd epochs for Bob.
\begin{itemize}
\item \textbf{Init.} A shared key $k$ is split into the PRF-PRNG key
  $k_\t{root}$ and a key for the CKA $k_\t{CKA}$. $k_\t{root}$ serves
  to create the first PRF-PRNG state $\sigma_\t{root}$ which in
  turn is used to derive a initialization key for the initial
  FS-AEAD sender and receiver states stored in $v[0]$. Finally,
  $k_\t{CKA}$ is used to generate the initial CKA state $\gamma$. Let
  $t_\t{P}$ denote the current epoch for a user and $T_\t{cur}$ the
  current CKA update message.
\item \textbf{Send-P.} At the start of each epoch (if-branch) the user
  generates a new CKA update message $T_\t{cur}$ and update information $I$
  to create fresh FS-AEAD state. Furthermore, old FS-AEAD states from previous
  epochs of the user are erased from memory (not depicted in the figure).
  Whether it is the first message of a new epoch or not the FS-AEAD is
  always updated at the end with when encrypting
  the message where $t_\t{P}$ and $T_\t{cur}$ serve as associated data.
\item \textbf{Rcv-P.} Whenever the received messages marks the beginning
  of a new epoch the user has to update his state accordingly (elseif-branch)
  mirroring the operations performed by the partner in his send
  routine. Again in this case old FS-AEAD states can be erased
  from memory (not depicted). In every case the FS-AEAD state
  is then updated when decrypting the ciphertext.
\end{itemize}

\begin{figure}[ht]
  \centering
  \setlength{\fboxsep}{10pt}
  \scalebox{0.9}{%
    \fbox{%
      \input{figures/dratch.tex}
    }
  }
  \caption{Double Ratchet Protocol}
  \label{fig:double-ratchet}
\end{figure}

\chapter{Benchmarks}
\label{chap:benchmarks}

\chapter{Conclusion}
\label{chap:conclusion}


\bibliographystyle{plainurl}
\bibliography{bibliography}

\listoffigures

\end{document}
