// (c) 2018 EPFL
// This code is licensed under MIT license (see LICENSE.txt for details)

package hibe

import (
	"bytes"
	"crypto/sha256"
	"encoding/json"

	"github.com/Nik-U/pbc"
)

// pairing specifies the symmetric pairing function on the curve y^2=x^3+x over
// the finite field F_q of size 512 bits. The resulting group is of size 160 bits.
//
// TODO: Find a way to dynamically create the pairing instead of hard-coding it.
// TODO: Use point compression to mitigate ciphertext expansion.
var pairing = pbc.GenerateA(160, 512).NewPairing()

// gentry designates a Gentry-Silverberg protocol instance.
type gentry struct{}

// gentryParams composes the public parameters of a protocol instance.
type gentryParams struct {
	P0, Q0 *pbc.Element // P0 and Q0 are the generate elements of the protocol instance.
}

// gentryEntity designates a participant in the protocol. It can be both the root PKG,
// intermediate PKG or a simple user.
type gentryEntity struct {
	// ID is the public key of the entity. An entity at level t has an ID of length t,
	// the root PKG has an empty ID.
	ID [][]byte

	// P0 is the generator element chosen at the protocol start.
	P0 *pbc.Element
	// St is the constant secret scalar created when the entity comes to life.
	St *pbc.Element
	// S is the ephemeral secret received upon secret key extraction.
	S *pbc.Element

	// Q is a list of generator values received from the ancestor identity.
	Q []*pbc.Element
}

// gentryCiphertext bundles a cipher text.
type gentryCiphertext struct {
	U []*pbc.Element
}

// NewGentry creates a fresh protocol instance over symmetric pairing of groupe size r bits
// and an underlying finite field of size q bits.
func NewGentry() *gentry {
	return &gentry{}
}

// Setup establishes the public parameters and generates a root entity PKG.
// FIXME: Make better use of seed for sampling elements.
func (g *gentry) Setup(seed []byte) (params, root []byte, err error) {
	P0 := pairing.NewG1().SetFromStringHash(string(seed), sha256.New())

	s0 := pairing.NewZr().SetFromStringHash(string(seed), sha256.New())
	Q0 := pairing.NewG1().MulZn(P0, s0)

	p := &gentryParams{P0: P0, Q0: Q0}
	params, err = p.MarshalJSON()
	if err != nil {
		return
	}

	// Set ephemeral secret to the identity element.
	r := &gentryEntity{
		ID: [][]byte{},
		P0: P0, St: s0, S: pairing.NewG1().Set1(),
		Q: []*pbc.Element{},
	}
	root, err = r.MarshalJSON()
	return
}

// Extract generates a fresh child entity specified by id from a ancestor entity.
func (g gentry) Extract(ancestor []byte, id []byte) ([]byte, error) {
	var e gentryEntity
	if err := e.UnmarshalJSON(ancestor); err != nil {
		return nil, err
	}

	childID := append(e.ID, id)

	P := pairing.NewG1().SetFromStringHash(string(bytes.Join(childID, nil)), sha256.New())
	S := pairing.NewG1().Add(e.S, pairing.NewG1().MulZn(P, e.St))

	// FIXME: Constant secret should not be generated by the ancestor during key extraction
	// but at the beginning during the protocol setup.
	St := pairing.NewZr().Rand()
	Q := append(e.Q, pairing.NewG1().MulZn(e.P0, e.St))

	child := &gentryEntity{
		ID: childID,
		P0: e.P0, St: St, S: S,
		Q: Q,
	}
	return child.MarshalJSON()
}

// Encrypt encrypts a message for a given id. Note the ciphertext into two parts to simplify
// the integration in other protocols.
func (g gentry) Encrypt(params, message []byte, id [][]byte) (c1, c2 []byte, err error) {
	var p gentryParams
	if err = json.Unmarshal(params, &p); err != nil {
		return
	}

	P := make([]*pbc.Element, len(id))
	for i := 0; i < len(id); i++ {
		P[i] = pairing.NewG1().SetFromStringHash(string(bytes.Join(id[:i+1], nil)), sha256.New())
	}

	r := pairing.NewZr().Rand()

	// TODO: Hash pairing result (H_2 oracle in the paper).
	paired := pairing.NewGT().Pair(p.Q0, P[0])
	h := pairing.NewGT().MulZn(paired, r).Bytes()
	c1 = xor(message, h)

	ct := gentryCiphertext{}
	ct.U = make([]*pbc.Element, len(id)+1)
	ct.U[0] = pairing.NewG1().MulZn(p.P0, r)
	ct.U[1] = nil
	for i := 2; i <= len(id); i++ {
		ct.U[i] = pairing.NewG1().MulZn(P[i-1], r)
	}

	c2, err = ct.MarshalJSON()
	return
}

// Decrypt decrypts a given ciphertext using the secret key material of an entity.
func (g gentry) Decrypt(entity, c1, c2 []byte) ([]byte, error) {
	var e gentryEntity
	if err := e.UnmarshalJSON(entity); err != nil {
		return nil, err
	}

	var c gentryCiphertext
	if err := c.UnmarshalJSON(c2); err != nil {
		return nil, err
	}

	k := pairing.NewGT().Pair(c.U[0], e.S)
	for i := 2; i < len(c.U); i++ {
		k = pairing.NewGT().Sub(k, pairing.NewGT().Pair(e.Q[i-1], c.U[i]))
	}

	return xor(c1, k.Bytes()), nil
}

// xor computes the exclusive-or of two byte arrays.
// TODO: Refactor and rewrite xor into a robuster version.
func xor(a, b []byte) []byte {
	if a == nil {
		return b
	} else if b == nil {
		return a
	}

	c := make([]byte, len(a))
	for i := range a {
		c[i] = a[i] ^ b[i]
	}
	return c
}

// gentryParamsPacket is a helper structure that enables marshalling.
type gentryParamsPacket struct {
	P0, Q0 []byte
}

func (p gentryParams) MarshalJSON() ([]byte, error) {
	return json.Marshal(&gentryParamsPacket{P0: p.P0.Bytes(), Q0: p.Q0.Bytes()})
}

func (p *gentryParams) UnmarshalJSON(data []byte) error {
	var packet gentryParamsPacket
	if err := json.Unmarshal(data, &packet); err != nil {
		return err
	}
	p.P0 = pairing.NewG1().SetBytes(packet.P0)
	p.Q0 = pairing.NewG1().SetBytes(packet.Q0)
	return nil
}

// gentryEntityPacket is a helper structure that enables marshalling.
type gentryEntityPacket struct {
	ID        [][]byte
	P0, St, S []byte
	Q         [][]byte
}

func (e gentryEntity) MarshalJSON() ([]byte, error) {
	packet := gentryEntityPacket{ID: e.ID, P0: e.P0.Bytes(), St: e.St.Bytes(), S: e.S.Bytes()}
	for _, q := range e.Q {
		packet.Q = append(packet.Q, q.Bytes())
	}
	return json.Marshal(&packet)
}

func (e *gentryEntity) UnmarshalJSON(data []byte) error {
	var packet gentryEntityPacket
	if err := json.Unmarshal(data, &packet); err != nil {
		return err
	}

	e.ID = packet.ID
	e.P0 = pairing.NewG1().SetBytes(packet.P0)
	e.St = pairing.NewZr().SetBytes(packet.St)
	e.S = pairing.NewG1().SetBytes(packet.S)
	for _, q := range packet.Q {
		e.Q = append(e.Q, pairing.NewG1().SetBytes(q))
	}
	return nil
}

// gentryCiphertextPacket is a helper structure that enables marshalling and unmarshalling.
type gentryCiphertextPacket struct {
	U [][]byte
}

func (c gentryCiphertext) MarshalJSON() ([]byte, error) {
	packet := &gentryCiphertextPacket{}
	for _, u := range c.U {
		if u != nil {
			packet.U = append(packet.U, u.Bytes())
		} else {
			packet.U = append(packet.U, nil)
		}
	}
	return json.Marshal(&packet)
}

func (c *gentryCiphertext) UnmarshalJSON(data []byte) error {
	var packet gentryCiphertextPacket
	if err := json.Unmarshal(data, &packet); err != nil {
		return err
	}

	for _, u := range packet.U {
		if u != nil {
			c.U = append(c.U, pairing.NewG1().SetBytes(u))
		} else {
			c.U = append(c.U, nil)
		}
	}
	return nil
}
